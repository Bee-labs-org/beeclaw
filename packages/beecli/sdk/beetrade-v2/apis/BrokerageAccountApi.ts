/* tslint:disable */
/* eslint-disable */
/**
 * Beetrade API
 * API documentation for Beetrade
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  BaseResponseAny,
  BaseResponseArrayBrokerageAccount,
  BaseResponseArrayBrokerageAccountGroup,
  BaseResponseBalanceResponse,
  BaseResponseBrokerageAccount,
  BrokerageAccountRequestExample,
} from '../models/index';
import {
    BaseResponseAnyFromJSON,
    BaseResponseAnyToJSON,
    BaseResponseArrayBrokerageAccountFromJSON,
    BaseResponseArrayBrokerageAccountToJSON,
    BaseResponseArrayBrokerageAccountGroupFromJSON,
    BaseResponseArrayBrokerageAccountGroupToJSON,
    BaseResponseBalanceResponseFromJSON,
    BaseResponseBalanceResponseToJSON,
    BaseResponseBrokerageAccountFromJSON,
    BaseResponseBrokerageAccountToJSON,
    BrokerageAccountRequestExampleFromJSON,
    BrokerageAccountRequestExampleToJSON,
} from '../models/index';

export interface BrokerageAccountsBrokerageIdPostRequest {
    brokerageId: number;
    lang?: BrokerageAccountsBrokerageIdPostLangEnum;
}

export interface BrokerageAccountsGetRequest {
    tradingClientId?: number;
    lang?: BrokerageAccountsGetLangEnum;
}

export interface BrokerageAccountsGroupedGetRequest {
    lang?: BrokerageAccountsGroupedGetLangEnum;
}

export interface BrokerageAccountsIdBalanceGetRequest {
    id: number;
}

export interface BrokerageAccountsIdDeleteRequest {
    id: number;
    lang?: BrokerageAccountsIdDeleteLangEnum;
}

export interface BrokerageAccountsIdGetRequest {
    id: number;
    lang?: BrokerageAccountsIdGetLangEnum;
}

export interface BrokerageAccountsIdPutRequest {
    id: number;
    credentials: BrokerageAccountRequestExample;
    lang?: BrokerageAccountsIdPutLangEnum;
}

/**
 * 
 */
export class BrokerageAccountApi extends runtime.BaseAPI {

    /**
     * Creates request options for brokerageAccountsBrokerageIdPost without sending the request
     */
    async brokerageAccountsBrokerageIdPostRequestOpts(requestParameters: BrokerageAccountsBrokerageIdPostRequest): Promise<runtime.RequestOpts> {
        if (requestParameters['brokerageId'] == null) {
            throw new runtime.RequiredError(
                'brokerageId',
                'Required parameter "brokerageId" was null or undefined when calling brokerageAccountsBrokerageIdPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['lang'] != null) {
            headerParameters['lang'] = String(requestParameters['lang']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }


        let urlPath = `/brokerage-accounts/{brokerage_id}`;
        urlPath = urlPath.replace(`{${"brokerage_id"}}`, encodeURIComponent(String(requestParameters['brokerageId'])));

        return {
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        };
    }

    /**
     * Create a new brokerage account for the authenticated user by providing brokerage_id as path parameter and config field values in request body. The system will validate all required fields and validation rules before creating the account. Credentials will be validated via portfolio service API to ensure they are valid before account creation. If credentials cannot be validated (400/500 response), account creation will fail. Credentials will be encrypted based on the config field\'s is_encrypted setting. If accountId is provided, it will be used as provider_user_id. Otherwise, if provider_user_id is provided, it will be used. If neither is provided, a random 6-digit unique ID will be generated automatically. tradingClientId is required to link the account to a trading client. The account will be created with CONNECTED status. **Important**: OTP, accessToken, orderToken, isSaveOtp, loanPackageId, and otpType fields are NOT accepted in this endpoint - they must be collected AFTER account creation via PUT /credentials endpoint.
     * Create a new brokerage account with config field validation
     */
    async brokerageAccountsBrokerageIdPostRaw(requestParameters: BrokerageAccountsBrokerageIdPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BaseResponseBrokerageAccount>> {
        const requestOptions = await this.brokerageAccountsBrokerageIdPostRequestOpts(requestParameters);
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BaseResponseBrokerageAccountFromJSON(jsonValue));
    }

    /**
     * Create a new brokerage account for the authenticated user by providing brokerage_id as path parameter and config field values in request body. The system will validate all required fields and validation rules before creating the account. Credentials will be validated via portfolio service API to ensure they are valid before account creation. If credentials cannot be validated (400/500 response), account creation will fail. Credentials will be encrypted based on the config field\'s is_encrypted setting. If accountId is provided, it will be used as provider_user_id. Otherwise, if provider_user_id is provided, it will be used. If neither is provided, a random 6-digit unique ID will be generated automatically. tradingClientId is required to link the account to a trading client. The account will be created with CONNECTED status. **Important**: OTP, accessToken, orderToken, isSaveOtp, loanPackageId, and otpType fields are NOT accepted in this endpoint - they must be collected AFTER account creation via PUT /credentials endpoint.
     * Create a new brokerage account with config field validation
     */
    async brokerageAccountsBrokerageIdPost(requestParameters: BrokerageAccountsBrokerageIdPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BaseResponseBrokerageAccount> {
        const response = await this.brokerageAccountsBrokerageIdPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates request options for brokerageAccountsGet without sending the request
     */
    async brokerageAccountsGetRequestOpts(requestParameters: BrokerageAccountsGetRequest): Promise<runtime.RequestOpts> {
        const queryParameters: any = {};

        if (requestParameters['tradingClientId'] != null) {
            queryParameters['trading_client_id'] = requestParameters['tradingClientId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['lang'] != null) {
            headerParameters['lang'] = String(requestParameters['lang']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }


        let urlPath = `/brokerage-accounts`;

        return {
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        };
    }

    /**
     * Get all brokerage accounts for the authenticated user without credentials. Optionally filter by trading_client_id.
     * Get all brokerage accounts
     */
    async brokerageAccountsGetRaw(requestParameters: BrokerageAccountsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BaseResponseArrayBrokerageAccount>> {
        const requestOptions = await this.brokerageAccountsGetRequestOpts(requestParameters);
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BaseResponseArrayBrokerageAccountFromJSON(jsonValue));
    }

    /**
     * Get all brokerage accounts for the authenticated user without credentials. Optionally filter by trading_client_id.
     * Get all brokerage accounts
     */
    async brokerageAccountsGet(requestParameters: BrokerageAccountsGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BaseResponseArrayBrokerageAccount> {
        const response = await this.brokerageAccountsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates request options for brokerageAccountsGroupedGet without sending the request
     */
    async brokerageAccountsGroupedGetRequestOpts(requestParameters: BrokerageAccountsGroupedGetRequest): Promise<runtime.RequestOpts> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['lang'] != null) {
            headerParameters['lang'] = String(requestParameters['lang']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }


        let urlPath = `/brokerage-accounts/grouped`;

        return {
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        };
    }

    /**
     * Retrieve all brokerage accounts for the authenticated user, grouped by their trading client relationship. Accounts without a trading client are grouped under the \"DEFAULT\" key. Accounts linked to trading clients are grouped by trading client ID with the trading client name included.
     * Get brokerage accounts grouped by trading client
     */
    async brokerageAccountsGroupedGetRaw(requestParameters: BrokerageAccountsGroupedGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BaseResponseArrayBrokerageAccountGroup>> {
        const requestOptions = await this.brokerageAccountsGroupedGetRequestOpts(requestParameters);
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BaseResponseArrayBrokerageAccountGroupFromJSON(jsonValue));
    }

    /**
     * Retrieve all brokerage accounts for the authenticated user, grouped by their trading client relationship. Accounts without a trading client are grouped under the \"DEFAULT\" key. Accounts linked to trading clients are grouped by trading client ID with the trading client name included.
     * Get brokerage accounts grouped by trading client
     */
    async brokerageAccountsGroupedGet(requestParameters: BrokerageAccountsGroupedGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BaseResponseArrayBrokerageAccountGroup> {
        const response = await this.brokerageAccountsGroupedGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates request options for brokerageAccountsIdBalanceGet without sending the request
     */
    async brokerageAccountsIdBalanceGetRequestOpts(requestParameters: BrokerageAccountsIdBalanceGetRequest): Promise<runtime.RequestOpts> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling brokerageAccountsIdBalanceGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }


        let urlPath = `/brokerage-accounts/{id}/balance`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        return {
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        };
    }

    /**
     * Get current account balance for a specific brokerage account
     * Get account balance
     */
    async brokerageAccountsIdBalanceGetRaw(requestParameters: BrokerageAccountsIdBalanceGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BaseResponseBalanceResponse>> {
        const requestOptions = await this.brokerageAccountsIdBalanceGetRequestOpts(requestParameters);
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BaseResponseBalanceResponseFromJSON(jsonValue));
    }

    /**
     * Get current account balance for a specific brokerage account
     * Get account balance
     */
    async brokerageAccountsIdBalanceGet(requestParameters: BrokerageAccountsIdBalanceGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BaseResponseBalanceResponse> {
        const response = await this.brokerageAccountsIdBalanceGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates request options for brokerageAccountsIdDelete without sending the request
     */
    async brokerageAccountsIdDeleteRequestOpts(requestParameters: BrokerageAccountsIdDeleteRequest): Promise<runtime.RequestOpts> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling brokerageAccountsIdDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['lang'] != null) {
            headerParameters['lang'] = String(requestParameters['lang']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }


        let urlPath = `/brokerage-accounts/{id}`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        return {
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        };
    }

    /**
     * Delete a brokerage account and all its credentials. Only the account owner can delete their account. All associated credentials will be automatically deleted via cascade delete.
     * Delete brokerage account
     */
    async brokerageAccountsIdDeleteRaw(requestParameters: BrokerageAccountsIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const requestOptions = await this.brokerageAccountsIdDeleteRequestOpts(requestParameters);
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a brokerage account and all its credentials. Only the account owner can delete their account. All associated credentials will be automatically deleted via cascade delete.
     * Delete brokerage account
     */
    async brokerageAccountsIdDelete(requestParameters: BrokerageAccountsIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.brokerageAccountsIdDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Creates request options for brokerageAccountsIdGet without sending the request
     */
    async brokerageAccountsIdGetRequestOpts(requestParameters: BrokerageAccountsIdGetRequest): Promise<runtime.RequestOpts> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling brokerageAccountsIdGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['lang'] != null) {
            headerParameters['lang'] = String(requestParameters['lang']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }


        let urlPath = `/brokerage-accounts/{id}`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        return {
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        };
    }

    /**
     * Get a brokerage account by ID with credentials (decrypted)
     * Get brokerage account by ID
     */
    async brokerageAccountsIdGetRaw(requestParameters: BrokerageAccountsIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BaseResponseBrokerageAccount>> {
        const requestOptions = await this.brokerageAccountsIdGetRequestOpts(requestParameters);
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BaseResponseBrokerageAccountFromJSON(jsonValue));
    }

    /**
     * Get a brokerage account by ID with credentials (decrypted)
     * Get brokerage account by ID
     */
    async brokerageAccountsIdGet(requestParameters: BrokerageAccountsIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BaseResponseBrokerageAccount> {
        const response = await this.brokerageAccountsIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates request options for brokerageAccountsIdPut without sending the request
     */
    async brokerageAccountsIdPutRequestOpts(requestParameters: BrokerageAccountsIdPutRequest): Promise<runtime.RequestOpts> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling brokerageAccountsIdPut().'
            );
        }

        if (requestParameters['credentials'] == null) {
            throw new runtime.RequiredError(
                'credentials',
                'Required parameter "credentials" was null or undefined when calling brokerageAccountsIdPut().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['lang'] != null) {
            headerParameters['lang'] = String(requestParameters['lang']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }


        let urlPath = `/brokerage-accounts/{id}`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        return {
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: BrokerageAccountRequestExampleToJSON(requestParameters['credentials']),
        };
    }

    /**
     * Update credentials (keys) for an existing brokerage account. Only provided fields will be updated (partial update). The system will validate all provided fields against config field rules and check uniqueness where required. Updated credentials will be validated via portfolio service API to ensure they are valid before updating. If credentials cannot be validated (400/500 response), the update will fail. New credentials can be added if the config field doesn\'t exist yet. If accountId is provided, it will be used to update provider_user_id. Otherwise, if provider_user_id is provided, it will be used to update provider_user_id. Optionally, provide tradingClientId to link/unlink the account to/from a trading client (set to \"null\" to unlink). Only the authenticated user who owns the account can update credentials. **Limited field support**: This endpoint ONLY accepts `loanPackageId` and `otpType` (SELECT with SMART_OTP/SMS_OTP options) for brokerages that have these config fields defined. **Note**: OTP, accessToken, orderToken, and isSaveOtp fields are NOT accepted in this endpoint - they have separate dedicated update endpoints/forms. Field availability is determined dynamically based on config fields, not hardcoded brokerage codes.
     * Update brokerage account credentials
     */
    async brokerageAccountsIdPutRaw(requestParameters: BrokerageAccountsIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BaseResponseBrokerageAccount>> {
        const requestOptions = await this.brokerageAccountsIdPutRequestOpts(requestParameters);
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BaseResponseBrokerageAccountFromJSON(jsonValue));
    }

    /**
     * Update credentials (keys) for an existing brokerage account. Only provided fields will be updated (partial update). The system will validate all provided fields against config field rules and check uniqueness where required. Updated credentials will be validated via portfolio service API to ensure they are valid before updating. If credentials cannot be validated (400/500 response), the update will fail. New credentials can be added if the config field doesn\'t exist yet. If accountId is provided, it will be used to update provider_user_id. Otherwise, if provider_user_id is provided, it will be used to update provider_user_id. Optionally, provide tradingClientId to link/unlink the account to/from a trading client (set to \"null\" to unlink). Only the authenticated user who owns the account can update credentials. **Limited field support**: This endpoint ONLY accepts `loanPackageId` and `otpType` (SELECT with SMART_OTP/SMS_OTP options) for brokerages that have these config fields defined. **Note**: OTP, accessToken, orderToken, and isSaveOtp fields are NOT accepted in this endpoint - they have separate dedicated update endpoints/forms. Field availability is determined dynamically based on config fields, not hardcoded brokerage codes.
     * Update brokerage account credentials
     */
    async brokerageAccountsIdPut(requestParameters: BrokerageAccountsIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BaseResponseBrokerageAccount> {
        const response = await this.brokerageAccountsIdPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
  * @export
  * @enum {string}
  */
export enum BrokerageAccountsBrokerageIdPostLangEnum {
    En = 'en',
    Vi = 'vi'
}
/**
  * @export
  * @enum {string}
  */
export enum BrokerageAccountsGetLangEnum {
    En = 'en',
    Vi = 'vi'
}
/**
  * @export
  * @enum {string}
  */
export enum BrokerageAccountsGroupedGetLangEnum {
    En = 'en',
    Vi = 'vi'
}
/**
  * @export
  * @enum {string}
  */
export enum BrokerageAccountsIdDeleteLangEnum {
    En = 'en',
    Vi = 'vi'
}
/**
  * @export
  * @enum {string}
  */
export enum BrokerageAccountsIdGetLangEnum {
    En = 'en',
    Vi = 'vi'
}
/**
  * @export
  * @enum {string}
  */
export enum BrokerageAccountsIdPutLangEnum {
    En = 'en',
    Vi = 'vi'
}
