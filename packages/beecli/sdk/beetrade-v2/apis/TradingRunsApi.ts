/* tslint:disable */
/* eslint-disable */
/**
 * Beetrade API
 * API documentation for Beetrade
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  BaseResponseAny,
  BaseResponsePerformanceMetrics,
  BaseResponseStopTradingRunResponse,
  BaseResponseStopTypesResponse,
  BaseResponseTradingRun,
  ListTradingRunsResponse,
} from '../models/index';
import {
    BaseResponseAnyFromJSON,
    BaseResponseAnyToJSON,
    BaseResponsePerformanceMetricsFromJSON,
    BaseResponsePerformanceMetricsToJSON,
    BaseResponseStopTradingRunResponseFromJSON,
    BaseResponseStopTradingRunResponseToJSON,
    BaseResponseStopTypesResponseFromJSON,
    BaseResponseStopTypesResponseToJSON,
    BaseResponseTradingRunFromJSON,
    BaseResponseTradingRunToJSON,
    ListTradingRunsResponseFromJSON,
    ListTradingRunsResponseToJSON,
} from '../models/index';

export interface TradingRunsGetRequest {
    sourceType?: string;
    strategyId?: number;
    brokerageAccountId?: number;
    brokerageId?: number;
    botTypeId?: number;
    runType?: TradingRunsGetRunTypeEnum;
    status?: TradingRunsGetStatusEnum;
    startDate?: string;
    endDate?: string;
    page?: number;
    pageSize?: number;
    orderBy?: TradingRunsGetOrderByEnum;
    orderDirection?: TradingRunsGetOrderDirectionEnum;
}

export interface TradingRunsIdDeleteRequest {
    id: string;
}

export interface TradingRunsIdGetRequest {
    id: string;
}

export interface TradingRunsIdPerformanceGetRequest {
    id: string;
}

export interface TradingRunsIdPutRequest {
    id: string;
    request: { [key: string]: any; };
}

export interface TradingRunsIdStopPostRequest {
    id: string;
}

/**
 * 
 */
export class TradingRunsApi extends runtime.BaseAPI {

    /**
     * Creates request options for tradingRunsGet without sending the request
     */
    async tradingRunsGetRequestOpts(requestParameters: TradingRunsGetRequest): Promise<runtime.RequestOpts> {
        const queryParameters: any = {};

        if (requestParameters['sourceType'] != null) {
            queryParameters['source_type'] = requestParameters['sourceType'];
        }

        if (requestParameters['strategyId'] != null) {
            queryParameters['strategy_id'] = requestParameters['strategyId'];
        }

        if (requestParameters['brokerageAccountId'] != null) {
            queryParameters['brokerage_account_id'] = requestParameters['brokerageAccountId'];
        }

        if (requestParameters['brokerageId'] != null) {
            queryParameters['brokerage_id'] = requestParameters['brokerageId'];
        }

        if (requestParameters['botTypeId'] != null) {
            queryParameters['bot_type_id'] = requestParameters['botTypeId'];
        }

        if (requestParameters['runType'] != null) {
            queryParameters['run_type'] = requestParameters['runType'];
        }

        if (requestParameters['status'] != null) {
            queryParameters['status'] = requestParameters['status'];
        }

        if (requestParameters['startDate'] != null) {
            queryParameters['start_date'] = requestParameters['startDate'];
        }

        if (requestParameters['endDate'] != null) {
            queryParameters['end_date'] = requestParameters['endDate'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        if (requestParameters['orderBy'] != null) {
            queryParameters['order_by'] = requestParameters['orderBy'];
        }

        if (requestParameters['orderDirection'] != null) {
            queryParameters['order_direction'] = requestParameters['orderDirection'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }


        let urlPath = `/trading-runs`;

        return {
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        };
    }

    /**
     * Get paginated list of trading runs for the authenticated user
     * List trading runs
     */
    async tradingRunsGetRaw(requestParameters: TradingRunsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListTradingRunsResponse>> {
        const requestOptions = await this.tradingRunsGetRequestOpts(requestParameters);
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListTradingRunsResponseFromJSON(jsonValue));
    }

    /**
     * Get paginated list of trading runs for the authenticated user
     * List trading runs
     */
    async tradingRunsGet(requestParameters: TradingRunsGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListTradingRunsResponse> {
        const response = await this.tradingRunsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates request options for tradingRunsIdDelete without sending the request
     */
    async tradingRunsIdDeleteRequestOpts(requestParameters: TradingRunsIdDeleteRequest): Promise<runtime.RequestOpts> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling tradingRunsIdDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }


        let urlPath = `/trading-runs/{id}`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        return {
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        };
    }

    /**
     * Delete a specific trading run by UUID
     * Delete trading run
     */
    async tradingRunsIdDeleteRaw(requestParameters: TradingRunsIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const requestOptions = await this.tradingRunsIdDeleteRequestOpts(requestParameters);
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a specific trading run by UUID
     * Delete trading run
     */
    async tradingRunsIdDelete(requestParameters: TradingRunsIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.tradingRunsIdDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Creates request options for tradingRunsIdGet without sending the request
     */
    async tradingRunsIdGetRequestOpts(requestParameters: TradingRunsIdGetRequest): Promise<runtime.RequestOpts> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling tradingRunsIdGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }


        let urlPath = `/trading-runs/{id}`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        return {
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        };
    }

    /**
     * Get a specific trading run by UUID for the authenticated user
     * Get trading run by ID
     */
    async tradingRunsIdGetRaw(requestParameters: TradingRunsIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BaseResponseTradingRun>> {
        const requestOptions = await this.tradingRunsIdGetRequestOpts(requestParameters);
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BaseResponseTradingRunFromJSON(jsonValue));
    }

    /**
     * Get a specific trading run by UUID for the authenticated user
     * Get trading run by ID
     */
    async tradingRunsIdGet(requestParameters: TradingRunsIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BaseResponseTradingRun> {
        const response = await this.tradingRunsIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates request options for tradingRunsIdPerformanceGet without sending the request
     */
    async tradingRunsIdPerformanceGetRequestOpts(requestParameters: TradingRunsIdPerformanceGetRequest): Promise<runtime.RequestOpts> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling tradingRunsIdPerformanceGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }


        let urlPath = `/trading-runs/{id}/performance`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        return {
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        };
    }

    /**
     * Get detailed performance metrics for a specific trading run including PnL, Sharpe ratio, drawdown, etc.
     * Get trading run performance metrics
     */
    async tradingRunsIdPerformanceGetRaw(requestParameters: TradingRunsIdPerformanceGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BaseResponsePerformanceMetrics>> {
        const requestOptions = await this.tradingRunsIdPerformanceGetRequestOpts(requestParameters);
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BaseResponsePerformanceMetricsFromJSON(jsonValue));
    }

    /**
     * Get detailed performance metrics for a specific trading run including PnL, Sharpe ratio, drawdown, etc.
     * Get trading run performance metrics
     */
    async tradingRunsIdPerformanceGet(requestParameters: TradingRunsIdPerformanceGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BaseResponsePerformanceMetrics> {
        const response = await this.tradingRunsIdPerformanceGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates request options for tradingRunsIdPut without sending the request
     */
    async tradingRunsIdPutRequestOpts(requestParameters: TradingRunsIdPutRequest): Promise<runtime.RequestOpts> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling tradingRunsIdPut().'
            );
        }

        if (requestParameters['request'] == null) {
            throw new runtime.RequiredError(
                'request',
                'Required parameter "request" was null or undefined when calling tradingRunsIdPut().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }


        let urlPath = `/trading-runs/{id}`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        return {
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['request'],
        };
    }

    /**
     * Update a specific trading run by UUID
     * Update trading run
     */
    async tradingRunsIdPutRaw(requestParameters: TradingRunsIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BaseResponseTradingRun>> {
        const requestOptions = await this.tradingRunsIdPutRequestOpts(requestParameters);
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BaseResponseTradingRunFromJSON(jsonValue));
    }

    /**
     * Update a specific trading run by UUID
     * Update trading run
     */
    async tradingRunsIdPut(requestParameters: TradingRunsIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BaseResponseTradingRun> {
        const response = await this.tradingRunsIdPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates request options for tradingRunsIdStopPost without sending the request
     */
    async tradingRunsIdStopPostRequestOpts(requestParameters: TradingRunsIdStopPostRequest): Promise<runtime.RequestOpts> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling tradingRunsIdStopPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }


        let urlPath = `/trading-runs/{id}/stop`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        return {
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        };
    }

    /**
     * Stop a running trading run (backtest, paper, or live) by trading run ID. Works for both strategies and bots.
     * Stop trading run
     */
    async tradingRunsIdStopPostRaw(requestParameters: TradingRunsIdStopPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BaseResponseStopTradingRunResponse>> {
        const requestOptions = await this.tradingRunsIdStopPostRequestOpts(requestParameters);
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BaseResponseStopTradingRunResponseFromJSON(jsonValue));
    }

    /**
     * Stop a running trading run (backtest, paper, or live) by trading run ID. Works for both strategies and bots.
     * Stop trading run
     */
    async tradingRunsIdStopPost(requestParameters: TradingRunsIdStopPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BaseResponseStopTradingRunResponse> {
        const response = await this.tradingRunsIdStopPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates request options for tradingRunsStopTypesGet without sending the request
     */
    async tradingRunsStopTypesGetRequestOpts(): Promise<runtime.RequestOpts> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }


        let urlPath = `/trading-runs/stop-types`;

        return {
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        };
    }

    /**
     * Get all available LEAN command types with support status
     * Get Trading Run Stop Types
     */
    async tradingRunsStopTypesGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BaseResponseStopTypesResponse>> {
        const requestOptions = await this.tradingRunsStopTypesGetRequestOpts();
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BaseResponseStopTypesResponseFromJSON(jsonValue));
    }

    /**
     * Get all available LEAN command types with support status
     * Get Trading Run Stop Types
     */
    async tradingRunsStopTypesGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BaseResponseStopTypesResponse> {
        const response = await this.tradingRunsStopTypesGetRaw(initOverrides);
        return await response.value();
    }

}

/**
  * @export
  * @enum {string}
  */
export enum TradingRunsGetRunTypeEnum {
    Backtest = 'BACKTEST',
    Live = 'LIVE',
    Paper = 'PAPER'
}
/**
  * @export
  * @enum {string}
  */
export enum TradingRunsGetStatusEnum {
    Pending = 'PENDING',
    Init = 'INIT',
    Running = 'RUNNING',
    Stopped = 'STOPPED',
    Completed = 'COMPLETED',
    Failed = 'FAILED',
    Cancelled = 'CANCELLED',
    Timeout = 'TIMEOUT',
    Pending2 = 'PENDING',
    Init2 = 'INIT',
    Running2 = 'RUNNING',
    Stopping = 'STOPPING',
    Completed2 = 'COMPLETED',
    Failed2 = 'FAILED',
    Cancelled2 = 'CANCELLED',
    Timeout2 = 'TIMEOUT'
}
/**
  * @export
  * @enum {string}
  */
export enum TradingRunsGetOrderByEnum {
    CreatedAt = 'created_at',
    StartedAt = 'started_at',
    TotalPnl = 'total_pnl'
}
/**
  * @export
  * @enum {string}
  */
export enum TradingRunsGetOrderDirectionEnum {
    Asc = 'asc',
    Desc = 'desc'
}
